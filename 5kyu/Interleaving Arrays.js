// Create a function, that accepts an arbitrary number of arrays and returns a single array generated by alternately appending elements from the passed in arguments. If one of them is shorter than the others, the result should be padded with empty elements.


// Examples:

// interleave([1, 2, 3], ["c", "d", "e"]) === [1, "c", 2, "d", 3, "e"]
// interleave([1, 2, 3], [4, 5]) === [1, 4, 2, 5, 3, null]
// interleave([1, 2, 3], [4, 5, 6], [7, 8, 9]) === [1, 4, 7, 2, 5, 8, 3, 6, 9]
// interleave([]) === []



// My Solution

function interleave() {
    const weave = [],
          argArr = Object.values(arguments)
   
    
    while(argArr.some( arr => arr.length !== 0)){
      for ( arr of argArr) {
        let val = arr.shift()
        weave.push( val ? val : typeof val === "number" ? val : null)
      }
    }
    return weave
  }


// Code Wars Alternatives

const interleave = (...a) => {
    let interleaved = []
    const longest = a.reduce((a, b) => (a.length > b.length ? a : b));
  
    for (let i in longest) {
      a.forEach(word => word[i] === undefined ? interleaved.push(null) : interleaved.push(word[i]));
    }
    return interleaved;
  };

  
  // Or

  function interleave(...arrs) {
    const l = Math.max(...arrs.map(a => a.length));
    return Array.from({ length: l }, (_, i) => arrs.flatMap(a => a[i] ?? null)).flat();
}